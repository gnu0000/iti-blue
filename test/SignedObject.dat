MIME-Version: 1.0
Content-Type: multipart/signed; protocol="application/x-pkcs7-signature"; micalg=sha1; boundary="----0F3773C9201C6A31C3017857D8BD24B3"

This is an S/MIME signed message

------0F3773C9201C6A31C3017857D8BD24B3
#!/Perl/bin/perl
#

use strict;
use warnings;
use URI::Escape;
use Digest::MD5 qw(md5);
use HTTP::Request::Common;
use HTTP::Request::Common qw(POST $DYNAMIC_FILE_UPLOAD);
use LWP::Simple qw(get);
use LWP::UserAgent;
use Time::HiRes qw(gettimeofday tv_interval);
use XML::LibXML;

# constants (for now...)
my $WORDY = 0;

# globals
#
my $LAST_REQUEST     = {};
my $LAST_RESPONSE    = {};
my $ASSERT_INDEX     = 0;
my $ASSERT_FAILURES  = 0;


   my $url = $ARGV[0] || "http://blue";
#  Usage() if (scalar @ARGV != 1);

   SetUser   ("craig", "password");
   CertTest ($url);

#   Test_9 ($url);
#   Test_Sig ($url);
#   Test_Basic_Workflow ($url);
   print "$ASSERT_FAILURES failures.\n";
#  print "\07" if $ASSERT_FAILURES; # beep!
   
   exit (0);

###############################################################################
#
# Tests
#


sub CertTest
   { 
   my ($url) = @_;

   my $namespace   = "craigspace"  ;
   my $bucket      = "test-a"      ;
   my $parent_cert = "thawte_root.der";
   my $signed_file = "SignedObject.dat";

   SetUser(); 
   Delete ("$url/$namespace/$bucket/");
   Put    ("$url/$namespace/cert/$parent_cert");

   Put    ("$url/$namespace/cert/$parent_cert");


sub Test_Sig
   {
   my $namespace   = "craigspace"  ;
   my $bucket      = "test-a"      ;
   my $parent_cert = "SignRoot.cer";
   my $signed_file = "SignedObject.dat";

   Get ("$url/$namespace/"); 

   #upload the cert
   _Upload_Object_Y ($url, $namespace, "cert", $parent_cert, $parent_cert, "x-application/octet-stream", "comment=sample signing parent cert");
   Get ("$url/$namespace/cert/");

   # make sig-required bucket
   SetHeader ("X-Bucket-Signature-Cert", $parent_cert);
   _Create_Bucket_Y ($url, $namespace, $bucket,  "Lockbox", "comment=For testing Signatures");

   #upload a signed object
   _Upload_Object_Y ($url, $namespace, $bucket,  $signed_file, $signed_file);

   Get ("$url/$namespace/$bucket"); 
   
#   _Delete_Bucket_Y ($url, $namespace, $bucket);
   }


sub Test_9
   {
   my ($url) = @_;

   SetUser(); 
   Delete ("$url/craigspace/tb1/"); 

   SetUser   ();
   SetHeader ("X-Bucket-Policy", '[RW.W..]');
   SetHeader ("X-Custom-Metadata", "foo=bar");
   Put       ("$url/craigspace/tb1/"); 

   DumpRequest ();
   DumpResponse ();
   }



#    DumpRequest  ();
#    DumpResponse (1);
# 
sub Test_Basic_Workflow
   {
   my ($url) = @_;

   #setup
   SetUser(); Delete ("$url/craigspace/testbucket/"); 
   SetUser(); Delete ("$url/craigspace/testbucket2/"); 

   #make buckets
   _Create_Bucket_Y ($url, "craigspace", "testbucket",  "private", "a=b,c=d,e=g,g=h"         );
   _Create_Bucket_Y ($url, "craigspace", "testbucket2", "public" , "bingo=bango,bongo=irving");

   #make/upload samples
   _make_sample ("a.in", 1024 * 1 );
   _make_sample ('b.in', 1024 * 16 );
   _Upload_Object_Y ($url, "craigspace", "testbucket", "a.dat", "a.in", "x-application/octet-stream", "foo=bar");
   _Upload_Object_Y ($url, "craigspace", "testbucket", "b.gz" , "b.in", "x-application/gzip"        , "fred=barney,wilma=betty");

   # get an index of my buckets
   Get ("$url/craigspace/"); 
   Assert_Code        (200, "GET $url/craigspace/");
   Assert_XML_Count   ("//buckets/bucket", 2);
   _Check_Namespace (1, "testbucket" , "craig", "[RW....]", "a=b,c=d,e=g,g=h"         );
   _Check_Namespace (2, "testbucket2", "craig", "[RWRWRW]", "bingo=bango,bongo=irving");

   # get an index of 1st bucket
   SetUser ();
   Get ("$url/craigspace/testbucket/"); 
   _Check_Bucket_Y ($url, "craigspace", "testbucket", "17408", "2", "0");
   _Check_Bucket_Object (1, "testbucket", "a.dat", "x-application/octet-stream", "1024",  "foo=bar"                );
   _Check_Bucket_Object (2, "testbucket", "b.gz" , "x-application/gzip"        , "16384", "fred=barney,wilma=betty");


   # success-get test object a.dat
   SetUser ();
   Get     ("$url/craigspace/testbucket/a.dat"); 
   _Check_Get_Object ($url, "craigspace", "testbucket", "a.dat", "a.in", "1024", "x-application/octet-stream", "foo=bar");

   # success-get test object
   SetUser ();
   Get     ("$url/craigspace/testbucket/b.gz"); 
   _Check_Get_Object ($url, "craigspace", "testbucket", "b.gz",  "b.in", 1024*16, "x-application/gzip", "fred=barney,wilma=betty");

   # success-get test object a.dat
   SetUser   ();
   Get                    ("$url/craigspace/testbucket/b.gz"                ); 
   Assert_Code            (200, "GET $url"                                  );
   Assert_Response_Header ("Content-Length"   , "16384"                     );
   Assert_Response_Header ("Content-Type"     , "x-application/gzip"        );
   Assert_Response_Header ("X-Custom-Metadata", "fred=barney,wilma=betty"   );


   # fail get non existing object
   SetUser   ();
   Get                    ("$url/craigspace/testbucket/nothete.txt"         ); 
   Assert_Code            (403, "GET $url"                                  );
   Assert_XML_Content     ("//error/message", "object 'craigspace/testbucket/nothete.txt' not found");
   
   _Delete_Bucket_Y ($url, "craigspace", "testbucket");
   _Delete_Bucket_Y ($url, "craigspace", "testbucket2");
   }




sub _Create_Bucket_Y
   {
   my ($url, $namespace, $bucket, $type, $metadata) = @_;

   _im_here(@_);

   # create a bucket
   SetUser   ();
   SetHeader ("X-Bucket-Policy", $type);
   SetHeader ("X-Custom-Metadata", $metadata);
   Put       ("$url/$namespace/$bucket/"); 

   Assert_Code            (200, "PUT $url");
   Assert_Response_Header ("Content-Type" , "text/xml"  ,                        );
   Assert_XML_Content     ("//response"   , "bucket '$namespace/$bucket' created");
   }


sub _Delete_Bucket_Y
   {
   my ($url, $namespace, $bucket) = @_;
   _im_here(@_);

   # remove the bucket
   SetUser ();
   Delete  ("$url/$namespace/$bucket/"); 
   Assert_Code            (200, "DELETE $url");
   Assert_Response_Header ("Content-Type" , "text/xml");
   Assert_XML_Content     ("//response", "bucket '$namespace/$bucket' removed");
   }


sub _Upload_Object_Y
   {
   my ($url, $namespace, $bucket, $object, $filespec, $content_type, $metadata) = @_;
   _im_here(@_);

   # upload a sample file
   SetUser   ();
   SetHeader ("Content-Type"              , $content_type      ) if $content_type;
   SetHeader ("X-Custom-Metadata"         , $metadata          ) if $metadata    ;
   SetHeader ("Content-MD5"               , GetMD5($filespec)  );
   SetHeader ("Content-Length"            , (stat $filespec)[7]);
   Put ("$url/$namespace/$bucket/$object" , $filespec          );

   Assert_Code            (200, "PUT $url/$namespace/$bucket/$object");
   Assert_XML_Content     ("//response", "object '$namespace/$bucket/$object' stored");
   }


sub _Check_Namespace
   {
   my ($index, $bucket, $owner, $policy, $metadata) = @_;
   _im_here(@_);

   Assert_XML_Content ("//buckets/bucket[$index]/name"           , $bucket  ) if defined $bucket  ;
   #Assert_XML_Content ("//buckets/bucket[$index]/owner"          , $owner   ) if defined $owner   ;
   Assert_XML_Content ("//buckets/bucket[$index]/policy"         , $policy  ) if defined $policy  ;
   Assert_XML_Content ("//buckets/bucket[$index]/custom_metadata", $metadata) if defined $metadata;
   }  


sub _Check_Bucket_Y
   {
   my ($url, $namespace, $bucket, $total_size, $object_count, $max_size)  = @_;
   _im_here(@_);

   # get an index of 1st bucket
   Assert_Code        (200, "GET $url/$namespace/$bucket") or return;
   Assert_XML_Content ("//bucket/total_size"  , $total_size  ) if defined $total_size  ;
   Assert_XML_Content ("//bucket/object_count", $object_count) if defined $object_count;
   Assert_XML_Content ("//bucket/max_size"    , $max_size    ) if defined $max_size    ;
   }


sub _Check_Bucket_Object
   {
   my ($object_index, $bucket, $object, $content_type, $content_length, $custom_metadata) = @_;

   _im_here(@_);
   Assert_XML_Content ("//bucket/objects/object[$object_index]/name"           , $object         ) if defined $object         ;
   Assert_XML_Content ("//bucket/objects/object[$object_index]/bucket"         , $bucket         ) if defined $bucket         ;
   Assert_XML_Content ("//bucket/objects/object[$object_index]/content_type"   , $content_type   ) if defined $content_type   ;
   Assert_XML_Content ("//bucket/objects/object[$object_index]/content_length" , $content_length ) if defined $content_length ;
   Assert_XML_Content ("//bucket/objects/object[$object_index]/custom_metadata", $custom_metadata) if defined $custom_metadata;
   }

sub _Check_Get_Object
   {
   my ($url, $namespace, $bucket, $object, $filespec, $object_size, $content_type, $metadata)  = @_;

   Assert_Code            (200, "GET $url/$namespace/$bucket/$object") || return;
   Assert_Response_Header ("Content-Length"   , $object_size         ) if defined $object_size ;
   Assert_Response_Header ("Content-Type"     , $content_type        ) if defined $content_type;
   Assert_Response_Header ("X-Custom-Metadata", $metadata            ) if defined $metadata    ;
#   Assert_CompareContent  ($filespec) if $object_size;
   }

##############################################################################
#
# request mechanics
#

sub Get
   {
   my ($url) = @_;

   _Request ('GET', $url);
   }


sub Post
   {
   my ($url, $infile) = @_;

   _Request ('POST', $url, $infile);
   }


sub Put
   {
   my ($url, $infile) = @_;

   _Request ('PUT', $url, $infile);
   }


sub Delete
   {
   my ($url) = @_;

   _Request ('DELETE', $url);
   }


sub Head
   {
   my ($url) = @_;

   _Request ('HEAD', $url);
   }


sub _Request
   {
   my ($verb, $url, $infile) = @_;

   my $agent    = LWP::UserAgent->new();
   my $request  = HTTP::Request->new ($verb => $url);
   AddHeaders ($request); 

   if (defined $infile)
      {
      my $data = $infile ? SlurpFile ($infile) : "";
      $request->content ($data);
      }
   StoreRequest ($verb, $url, $request);
   my $response = $agent->request($request);
   StoreResponse ($verb, $url, $response);
   ClearHeaders ();
   }


##############################################################################
#
# Util : headers management
#

my $HEADERS = {};


# store the headers
sub SetHeader
   {
   my ($name, $value) = @_;
   $HEADERS->{$name} = $value;
   }

sub HasHeader
   {
   my ($name) = @_;
   return defined $HEADERS->{$name};
   }



my $CURRENT_USER_ID    ;
my $CURRENT_USER_PASSWORD;

# SetUser('joe', 'password'); # add auth header
# SetUser();                  # add last defined user/pwd
# SetUser('','');             # clear user
#
sub SetUser
   {
   my ($userid, $password) = @_;

   $CURRENT_USER_ID       = $userid   if defined $userid; 
   $CURRENT_USER_PASSWORD = $password if defined $password; 

   SetHeader ("X-Blue-Authorization", "Basic userid=\"$CURRENT_USER_ID\",password=\"$CURRENT_USER_PASSWORD\"") 
      if $CURRENT_USER_ID || $CURRENT_USER_PASSWORD;
   }


# put the headers in the request
sub AddHeaders
   {
   my ($request) = @_;

   foreach my $key (keys %{$HEADERS})
      {
      $request->header ($key => $HEADERS->{$key});
      }
   }

sub ClearHeaders
   {
   $HEADERS = undef;
   }


##############################################################################
#
# util : save state
#

sub GetLastRequest  {return $LAST_REQUEST }
sub GetLastResponse {return $LAST_RESPONSE}

#
# necessary ?
#
sub StoreRequest
   {
   my ($verb, $url, $request) = @_;

   my $headers = {};
   map {$headers->{$_} = $request->header($_)} $request->header_field_names;


   $LAST_REQUEST  = {verb          => $verb                  ,    
                     url           => $url                   ,  
                     headers       => $headers               ,
                     time          => [gettimeofday]         };
   }

sub StoreResponse 
   {
   my ($verb, $url, $response) = @_;

   my $headers = {};
   map {$headers->{$_} = $response->header($_)} $response->header_field_names;

   $LAST_RESPONSE = {verb          => $verb                  ,    
                     url           => $url                   ,  
                     response      => $response              ,
                     response_code => $response->code        ,
                     is_success    => $response->is_success(),
                     headers       => $headers               ,
                     content       => $response->content()   ,
                     time          => [gettimeofday]         };
   }


sub DumpRequest
   {
   print "--------------------Request----------------------------\n";
   print "  Verb    : " . $LAST_REQUEST->{verb}                . "\n";
   print "  Url     : " . $LAST_REQUEST->{url}                 . "\n";
   print "  Headers : \n"; 
   DumpHeaders ($LAST_REQUEST->{headers});
   }


sub DumpResponse
   {
   my ($include_content) = @_;

   print "--------------------Response----------------------------\n";
   print "  Verb    : " . $LAST_RESPONSE->{verb}                . "\n";
   print "  Url     : " . $LAST_RESPONSE->{url}                 . "\n";
   print "  Code    : " . $LAST_RESPONSE->{response_code}       . "\n";
   print "  Headers : \n"; 
   DumpHeaders ($LAST_RESPONSE->{headers});
   (print "  Content : " . $LAST_RESPONSE->{content}             . "\n") if $include_content;
   print "--------------------------------------------------------\n";
   }

sub DumpHeaders
   {
   my ($headers) = @_;
   map {print "            $_: $headers->{$_}\n"} sort keys %{$headers};
   }


##############################################################################
#
# util : misc data file related utils
#

sub GetMD5
   {
   my ($filespec) = @_;

   my $filehandle;
   open ($filehandle, "<", $filespec) or return;
   binmode $filehandle;
   my $ctx = Digest::MD5->new;
   $ctx->addfile($filehandle);
   close ($filehandle);
   return $ctx->b64digest;
   }


sub SlurpFile
   {
   my ($filespec) = @_;

   my $filehandle;
   my $ok = open ($filehandle, "<", $filespec) or die ("Cannot open '$filespec' for reading");
   binmode $filehandle;
   my $contents;
   local $/ = undef;
   $contents = <$filehandle>;
   close $filehandle;
   return $contents;
   }

sub DumpFile
   {
   my ($filespec, $destdata) = @_;

   my $filehandle;
   open ($filehandle, ">", $filespec) or die ("Cannot open $filespec for writing");
   binmode $filehandle;
   print $filehandle $destdata;
   close ($filehandle);
   }


sub _make_sample
   {
   my ($filespec, $size) = @_;

   my ($fh, $pos);
   open ($fh, ">", $filespec) or die ("cannot open $filespec");
   binmode $fh;
   my $string = join ('', map {chr(rand(255))} (1..1024));
   for ($pos=0; $size-$pos >= 1024; $pos+=1024) {print $fh $string};
   print $fh substr ($string, 0, $size-$pos);
   close $fh;
   }


##############################################################################
#
# Asserts
#

# (200, "Create testbucket");
#
sub Assert_Code
   {
   my ($code, $assert_msg) = @_;

   my $response = GetLastResponse ();
   my $ok = ($response->{response_code} == $code);

   _AssertPrefix ($ok);
   my ($return_message) = _XML_Text ("//message");

   $return_message = $response->{content} if !defined $return_message || length $return_message < 4;

   print $ok ? "($code $assert_msg)" : "$code $assert_msg [$response->{response_code} <==> $code] $return_message";
   print "\n";
   return $ok;
   }

sub Assert_Content
   {
   my ($value, $assert_msg) = @_;

   my $response = GetLastResponse;
   my $content  = $response->{content};
   my $ok = $content =~ m/$value/is;

   _AssertPrefix ($ok);
   print $ok    ? "(content check)" : "'$content' found where '$value' expected.";
   print "\n";
   return $ok;
   }


sub Assert_Request_Header 
   {
   my ($header_name, $header_value, $assert_msg) = @_;

   my $request = GetLastRequest;
   my $headers  = $request->{headers};
   my $header   = $headers->{$header_name};
   my $ok       = defined $header && $headers->{$header_name} =~ m/$header_value/i;
            
   _AssertPrefix ($ok);
   print $ok ? "(request header check)" : "$assert_msg";
   print "\n";
   return $ok;
   }


sub Assert_Response_Header
   {
   my ($header_name, $header_value, $assert_msg) = @_;

   my $response = GetLastResponse;
   my $headers  = $response->{headers};
   my $header   = $headers->{$header_name};
   my $ok       = defined $header && $headers->{$header_name} =~ m/$header_value/i;
            
   _AssertPrefix ($ok);
   print "($header_name check)"                                  if  $ok;
   print "$header_name : expected '$header_value' got '$header'" if !$ok && $header;
   print "$header_name : header not present"                     if !$ok && $header;
   print "\n";
   return $ok;
   }



sub Assert_XML_Content
   {
   my ($xpath_expr, $value) = @_;

   my ($text, $ok) = _XML_Text ($xpath_expr);

   if (!$ok)
      {
      _AssertPrefix (0);
      print "no matching node: '$xpath_expr'\n";
      return 0;
      }
   $ok = $text =~ /$value/i;
   _AssertPrefix ($ok);
   print  $ok ? "('$xpath_expr' found '$text')\n" : "'$text' found where '$value' expected.\n";
   return $ok;
   }

#internal only
sub _XML_Text
   {
   my ($xpath_expr) = @_;

   my $xml = _ResponseXML ();
   my @nodes = $xml ? $xml->findnodes ($xpath_expr) : ();
   my $node_count = scalar @nodes;
   return (undef, 0) if (!$node_count); 
   my $node = $nodes[0];
   my $text = $node->textContent();
   return ($text, $node_count);
   }


sub Assert_XML_Count
   {
   my ($xpath_expr, $count) = @_;

   my $xml = _ResponseXML ();
   my @nodes = $xml->findnodes ($xpath_expr);

   my $actual_count = scalar @nodes;

   my $ok = $count == $actual_count;

   _AssertPrefix ($ok);
   print  $ok ? "(XML_Count: '$xpath_expr' found $count matches)\n" : "'$xpath_expr'  $actual_count matches found where $count expected.\n";
   return $ok;
   }


sub _ResponseXML
   {
   my $response = GetLastResponse ();

   if (!$response->{_parsed})
      {
      my $parser = XML::LibXML->new();
      $response->{_xml}         = eval {$parser->parse_string ($response->{content})};
      $response->{_parse_error} = $@;
      $response->{_parsed     } = 1;
      }
   return $response->{_xml};
   }

#sub Assert_CompareContent
#   {
#   my ($filespec) = @_;
#
#   my $fh;
#   my $buff1 = "";
#   open ($fh, "<", $filespec) or die ("cannot open $filespec");
#   binmode $fh;
#
#   my $response = GetLastResponse ();
#
#   my $ok = 1;
#   while (read($fh1, $buff1, 1024) && read($fh2, $buff2, 1024))
#      {
#      $ok = 0 if $buff1 ne $buff2;
#      }
#   close $fh1;
#   close $fh2;
#   print "filecompare '$filespec1' vs '$filespec2': " . ($ok ? "OK" : "Failed")    . "\n";
#
##todo...   
#   return 1;
#   }

sub _AssertPrefix
   {
   my ($ok) = @_;
   print sprintf ("  %2.2d : %s ", ++$ASSERT_INDEX, $ok ? "PASS" : "FAIL");
   $ASSERT_FAILURES += !$ok;
   }

##############################################################################
#
# Status
#

sub _im_here
   {
   my ($package, $filename, $line, $subr, $has_args, $wantarray) = caller (1);
   ($subr) = $subr =~ m{^.*::([^:]+)$};
   my $params = "(" . join (",", @_) . ")";
   print "$subr";
   print "$params" if $WORDY;
   print "\n";
   }


##############################################################################
#
# util : doc
#

sub Usage
   {
   print while <DATA>;
   exit (0);
   }


__DATA__
 
OCLIENT - Command line Queue utility
 
Usage: BTEST url
 
WHERE: url    - the blue elephant server URL
 

------0F3773C9201C6A31C3017857D8BD24B3
Content-Type: application/x-pkcs7-signature; name="smime.p7s"
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="smime.p7s"

MIIEgAYJKoZIhvcNAQcCoIIEcTCCBG0CAQExCzAJBgUrDgMCGgUAMAsGCSqGSIb3
DQEHAaCCAngwggJ0MIIB3aADAgECAhBXghp8IYvuJuMXsHPXl4P7MA0GCSqGSIb3
DQEBBQUAMGIxCzAJBgNVBAYTAlpBMSUwIwYDVQQKExxUaGF3dGUgQ29uc3VsdGlu
ZyAoUHR5KSBMdGQuMSwwKgYDVQQDEyNUaGF3dGUgUGVyc29uYWwgRnJlZW1haWwg
SXNzdWluZyBDQTAeFw0wODAyMjgxOTUxMzJaFw0wOTAyMjcxOTUxMzJaMFExHzAd
BgNVBAMTFlRoYXd0ZSBGcmVlbWFpbCBNZW1iZXIxLjAsBgkqhkiG9w0BCQEWH2Ny
YWlnLmZpdHpnZXJhbGRAaW5mb3RlY2hmbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQAD
gY0AMIGJAoGBAMAPbB9qs9zD1WkUKBqILIzM9Ir0KJkWnKhmKJ0Gk7UPXzFkJwot
xtPzzk3ytq3YQadwstXVO/EE5tcfG58qTG36PC7xPCEahtMucZqj+VCQcUG3RQdM
IPQKlA0TC6OOjG57RTUXG+FpqXjjv3FHYv8XDtk4tVd46AXnhPrdBjt3AgMBAAGj
PDA6MCoGA1UdEQQjMCGBH2NyYWlnLmZpdHpnZXJhbGRAaW5mb3RlY2hmbC5jb20w
DAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQUFAAOBgQBdS/Ck9mmTtrDPl8yOp7vC
/OCqYR61zcr3sATIUoyD1eNUUosAX4oo7e7rxTJivbFPxs/UFn132kz5hstt5EAj
Hyv7wqfvtxyABKGzTrA9nQg3sUg8CPwjUl1p05tDnv4M5OHngC8H6gAL/6MI7t4g
hImH7RCQx6JmGDRw0XaJuzGCAdAwggHMAgEBMHYwYjELMAkGA1UEBhMCWkExJTAj
BgNVBAoTHFRoYXd0ZSBDb25zdWx0aW5nIChQdHkpIEx0ZC4xLDAqBgNVBAMTI1Ro
YXd0ZSBQZXJzb25hbCBGcmVlbWFpbCBJc3N1aW5nIENBAhBXghp8IYvuJuMXsHPX
l4P7MAkGBSsOAwIaBQCggbEwGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkq
hkiG9w0BCQUxDxcNMDgwMjI5MTYzODMzWjAjBgkqhkiG9w0BCQQxFgQUODId8kxz
3aBU63M+64RGvO1ea8AwUgYJKoZIhvcNAQkPMUUwQzAKBggqhkiG9w0DBzAOBggq
hkiG9w0DAgICAIAwDQYIKoZIhvcNAwICAUAwBwYFKw4DAgcwDQYIKoZIhvcNAwIC
ASgwDQYJKoZIhvcNAQEBBQAEgYC3iVGIEAGoET181KY0EaQChG4AJCdsRyAeI56r
suwo7iEOq0uITTg9ZPbWh2NeJMNr65x7bvWqx6HYbC1q9lmkLGP9f2ik9us/Tm55
7lMyMIY2oEmohYRpt73de8dja3hrzIgLiUK1rd7I3q1QA6EkkT3DqFeFYRvKx1bA
o49Iuw==

------0F3773C9201C6A31C3017857D8BD24B3--

